{
  "language": "Solidity",
  "sources": {
    "contracts/BridgeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./library/RLPReader.sol\";\nimport \"./versions/Version0.sol\";\nimport \"./interfaces/IBridgeCosignerManager.sol\";\nimport \"./interfaces/IBridgeToken.sol\";\nimport \"./interfaces/IBridgeTokenManager.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IOwnable.sol\";\n\nabstract contract AbstractBridgeStorage is\n    Version0,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable\n{\n    mapping(address => uint256) internal _nonces;\n    mapping(bytes32 => bool) internal _commitments;\n\n    // (0.2%) hardcoded liquidity fee.\n    // In future: shared between syndicate, relayers and lp providers\n    uint256 public constant LIQUIDITY_FEE_NUMERATOR = 9980;\n    uint256 public constant LIQUIDITY_FEE_DENOMINATOR = 10000;\n\n    // ===== initialize override =====\n    IBridgeCosignerManager internal _cosignerManager;\n    IBridgeTokenManager internal _tokenManager;\n    string internal _name;\n    uint256 internal _chainId;\n    bytes32 public DOMAIN_SEPARATOR;\n\n    // ===== signing =====\n    bytes32 internal constant ENTER_EVENT_SIG =\n        keccak256(\"Enter(address,address,uint256,uint256,uint256,bytes32)\");\n\n    // ===== proxy =====\n\n    uint256[49] private __gap;\n\n    // ===== functionality to override =====\n\n    /**\n     * @dev Hook that is called after enter check. This includes\n     * token deposit in according to the bridge direction.\n     */\n    function enterProcess(\n        IBridgeTokenManager.Token memory tokenData,\n        uint256 amount\n    ) internal virtual;\n\n    /**\n     * @dev Hook that is called after exit check. This includes\n     * token withdraw in according to the bridge direction.\n     */\n    function exitProcess(\n        IBridgeTokenManager.Token memory tokenData,\n        address to,\n        uint256 amount\n    ) internal virtual;\n\n    // ===== domain =====\n\n    function getChainId() external view returns (uint256) {\n        return _chainId;\n    }\n\n    function _calculateDomainSeparator(string memory name, uint256 chainId)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(abi.encodePacked(VERSION)),\n                    chainId,\n                    address(this)\n                )\n            );\n    }\n}\n\ncontract BridgeRouter is AbstractBridgeStorage {\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    // Initialize function for proxy constructor. Must be used atomically\n    function initialize(\n        string memory name_,\n        IBridgeCosignerManager cosignerManager_,\n        IBridgeTokenManager tokenManager_\n    ) public initializer {\n        _name = name_;\n        _cosignerManager = cosignerManager_;\n        _tokenManager = tokenManager_;\n        assembly {\n            sstore(_chainId.slot, chainid())\n        }\n        DOMAIN_SEPARATOR = _calculateDomainSeparator(_name, _chainId);\n\n        // proxy inits\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n    }\n\n    event Enter(\n        address indexed token,\n        address indexed exitor,\n        uint256 amount,\n        uint256 nonce,\n        uint256 chainId,\n        bytes32 domain\n    );\n\n    function emitEnter(\n        address token,\n        address from,\n        uint256 amount\n    ) internal {\n        emit Enter(\n            token,\n            from,\n            amount,\n            _nonces[from],\n            _chainId,\n            _calculateDomainSeparator(_name, _chainId)\n        );\n        _nonces[from]++;\n    }\n\n    event Exit(\n        address indexed token,\n        address indexed exitor,\n        uint256 amount,\n        bytes32 commitment,\n        uint256 chainId,\n        bytes32 domain\n    );\n\n    function emitExit(\n        address token,\n        address to,\n        bytes32 commitment,\n        uint256 amount\n    ) internal {\n        emit Exit(\n            token,\n            to,\n            amount,\n            commitment,\n            _chainId,\n            _calculateDomainSeparator(_name, _chainId)\n        );\n    }\n\n    function unsafeTransfer(address to, uint256 amount) internal {\n        require(address(this).balance >= amount, \"BR: INSUFFICIENT_BALANCE\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"BR: SEND_REVERT\");\n    }\n\n    /**\n     * @notice Set the token manager, callable only by cosigners\n     * @dev This should be the contract responsible for checking and add tokens to crosschain mapping\n     * @param newTokenManager address of token manager contract\n     */\n    function setTokenManager(address newTokenManager) external onlyOwner {\n        require(newTokenManager != address(0), \"BR: ZERO_ADDRESS\");\n        _tokenManager = IBridgeTokenManager(newTokenManager);\n    }\n\n    /**\n     * @notice Get the address of contract set as token manager\n     * @return The address of token manager contract\n     */\n    function tokenManagerAddress() external view returns (address) {\n        return address(_tokenManager);\n    }\n\n    /**\n     * @notice Set the cosigner manager, callable only by cosigners\n     * @dev This should be the contract responsible for sign by behalf of the payloads\n     * @param newCosignerManager address of cosigner manager contract\n     */\n    function setCosignerManager(address newCosignerManager) external onlyOwner {\n        require(newCosignerManager != address(0), \"BR: ZERO_ADDRESS\");\n        _cosignerManager = IBridgeCosignerManager(newCosignerManager);\n    }\n\n    /**\n     * @notice Get the address of contract set as cosigner manager\n     * @return The address of cosigner manager contract\n     */\n    function cosignerManagerAddress() external view returns (address) {\n        return address(_cosignerManager);\n    }\n\n    // enter amount of tokens to protocol\n    function enter(address token, uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        require(token != address(0), \"BR: ZERO_ADDRESS\");\n        require(amount != 0, \"BR: ZERO_AMOUNT\");\n\n        (IBridgeTokenManager.Token memory tokenData, bool ok) = _tokenManager\n            .fetch(token, _chainId);\n        require(ok, \"BR: TOKEN_NOT_LISTED\");\n        enterProcess(tokenData, amount);\n\n        emitEnter(token, _msgSender(), amount);\n    }\n\n    // enter amount of system currency to protocol\n    function enterETH() external payable nonReentrant whenNotPaused {\n        require(msg.value != 0, \"BR: ZERO_AMOUNT\");\n        (, bool ok) = _tokenManager.fetch(address(0), _chainId);\n        require(ok, \"BR: TOKEN_NOT_LISTED\");\n\n        emitEnter(address(0), _msgSender(), msg.value);\n    }\n\n    // exit amount of tokens from protocol\n    function exit(bytes calldata data, bytes[] calldata signatures)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        RLPReader.RLPItem[] memory logRLPList = data.toRlpItem().toList();\n        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics\n\n        require(\n            bytes32(logTopicRLPList[0].toUint()) == ENTER_EVENT_SIG, // topic0 is event sig\n            \"BR: INVALID_EVT\"\n        );\n\n        address exitToken = logTopicRLPList[1].toAddress();\n        address to = logTopicRLPList[2].toAddress();\n        require(to == _msgSender(), \"BR: NOT_ONWER\");\n\n        uint256 amount = logRLPList[2].toUint();\n        require(amount != 0, \"BR: ZERO_AMOUNT\");\n\n        uint256 extChainId = logRLPList[3].toUint();\n        require(extChainId != _chainId, \"BR: WRONG_CHAIN\");\n\n        // protected from replay on another network\n        bytes32 commitment = keccak256(\n            abi.encodePacked(data, _calculateDomainSeparator(_name, _chainId))\n        );\n\n        require(!_commitments[commitment], \"BR: COMMITMENT_KNOWN\");\n        require(\n            _cosignerManager.verify(commitment, extChainId, signatures),\n            \"BR: INVALID_SIGNATURES\"\n        );\n\n        _commitments[commitment] = true;\n\n        (IBridgeTokenManager.Token memory enterToken, bool ok) = _tokenManager\n            .fetch(exitToken, extChainId);\n        require(ok, \"BR: TOKEN_NOT_LISTED\");\n\n        exitProcess(enterToken, to, amount);\n        emitExit(enterToken.addr, to, commitment, amount);\n    }\n\n    // ===== impl =====\n\n    function enterProcess(\n        IBridgeTokenManager.Token memory tokenData,\n        uint256 amount\n    ) internal override {\n        if (tokenData.issueType == IBridgeTokenManager.IssueType.MINTABLE) {\n            IBridgeToken(tokenData.addr).burn(_msgSender(), amount);\n        } else if (\n            tokenData.issueType == IBridgeTokenManager.IssueType.DEFAULT\n        ) {\n            IERC20(tokenData.addr).transferFrom(\n                _msgSender(),\n                address(this),\n                amount\n            );\n        } else {\n            // in case not correct choise, should not occur\n            assert(false);\n        }\n    }\n\n    function exitProcess(\n        IBridgeTokenManager.Token memory tokenData,\n        address to,\n        uint256 amount\n    ) internal override {\n        if (tokenData.addr == address(0)) {\n            unsafeTransfer(to, amount);\n        } else if (\n            tokenData.issueType == IBridgeTokenManager.IssueType.MINTABLE\n        ) {\n            IBridgeToken(tokenData.addr).mint(to, amount);\n        } else if (\n            tokenData.issueType == IBridgeTokenManager.IssueType.DEFAULT\n        ) {\n            IERC20(tokenData.addr).transfer(to, amount);\n        } else {\n            // in case not correct choise, should not occur\n            assert(false);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/library/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item)\n        internal\n        pure\n        returns (RLPItem memory)\n    {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self)\n        internal\n        pure\n        returns (Iterator memory)\n    {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item)\n        internal\n        pure\n        returns (uint256, uint256)\n    {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item)\n        internal\n        pure\n        returns (RLPItem[] memory)\n    {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item)\n        internal\n        pure\n        returns (bytes32)\n    {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item)\n        internal\n        pure\n        returns (bytes32)\n    {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (\n            byte0 < STRING_LONG_START ||\n            (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\n        ) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    },
    "contracts/versions/Version0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n/**\n * @title Version0\n * @notice Version getter for contracts\n **/\ncontract Version0 {\n    uint8 public constant VERSION = 0;\n}\n"
    },
    "contracts/interfaces/IBridgeCosignerManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IBridgeCosignerManager {\n    struct Cosigner {\n        address addr;\n        bool active;\n        uint256 chainId;\n    }\n\n    function verify(\n        bytes32 commitment,\n        uint256 chainId,\n        bytes[] calldata signatures\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IBridgeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBridgeToken is IERC20 {\n    function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) external;\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function burn(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n\n    function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IBridgeTokenManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IBridgeTokenManager {\n    event LinkAdded(Link indexed link);\n    event LinkRemoved(Link indexed link);\n\n    enum IssueType {\n        DEFAULT,\n        MINTABLE\n    }\n\n    struct Token {\n        address addr;\n        IssueType issueType;\n        uint256 chainId;\n    }\n\n    struct Link {\n        Token enterToken;\n        Token exitToken;\n        bool exist;\n    }\n\n    function issue(\n        address[] calldata tokens,\n        IssueType[] calldata issueTypes,\n        uint256[] calldata chainIds\n    ) external;\n\n    function revoke(address addr, uint256 chainId) external;\n\n    function fetch(address addr, uint256 chainId)\n        external\n        view\n        returns (Token memory token, bool ok);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IOwnable {\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/tokens/WrappedToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IWETH.sol\";\n\ncontract WrappedToken is ReentrancyGuard, IWETH {\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    function deposit() public payable override {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public override nonReentrant {\n        require(\n            balanceOf[msg.sender] >= wad,\n            \"WrappedToken: INSUFFICIENT_AMOUNT\"\n        );\n        balanceOf[msg.sender] -= wad;\n        (bool success, ) = msg.sender.call{value: wad}(\"\");\n        require(success, \"WrappedToken: TRANSFER_FAILED\");\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public override returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public override returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public override returns (bool) {\n        require(balanceOf[src] >= wad, \"WrappedToken: INSUFFICIENT_AMOUNT\");\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint256).max\n        ) {\n            require(\n                allowance[src][msg.sender] >= wad,\n                \"WrappedToken: INSUFFICIENT_ALLOWANCE\"\n            );\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/tokens/BridgeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/IBridgeToken.sol\";\nimport \"../versions/Version0.sol\";\n\ncontract BridgeToken is Version0, IBridgeToken, OwnableUpgradeable {\n    // ============ Memory ============\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private balances;\n\n    mapping(address => mapping(address => uint256)) private allowances;\n\n    uint256 private supply;\n\n    struct Token {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    Token internal token;\n\n    uint256[49] private __gap;\n\n    // ============ Initializer ============\n\n    function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) public override initializer {\n        __Ownable_init();\n        token.name = _name;\n        token.symbol = _symbol;\n        token.decimals = _decimals;\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Destroys `_amnt` tokens from `_from`, reducing the\n     * total supply.\n     * @dev Emits a {Transfer} event with `to` set to the zero address.\n     * Requirements:\n     * - `_from` cannot be the zero address.\n     * - `_from` must have at least `_amnt` tokens.\n     * @param _from The address from which to destroy the tokens\n     * @param _amnt The amount of tokens to be destroyed\n     */\n    function burn(address _from, uint256 _amnt) external override onlyOwner {\n        _burn(_from, _amnt);\n    }\n\n    /** @notice Creates `_amnt` tokens and assigns them to `_to`, increasing\n     * the total supply.\n     * @dev Emits a {Transfer} event with `from` set to the zero address.\n     * Requirements:\n     * - `to` cannot be the zero address.\n     * @param _to The destination address\n     * @param _amnt The amount of tokens to be minted\n     */\n    function mint(address _to, uint256 _amnt) external override onlyOwner {\n        _mint(_to, _amnt);\n    }\n\n    /**\n     * @dev This is calculated at runtime\n     * because the token name may change\n     */\n    function domainSeparator() public view override returns (bytes32) {\n        uint256 _chainId;\n        assembly {\n            _chainId := chainid()\n        }\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(token.name)),\n                    keccak256(abi.encodePacked(VERSION)),\n                    _chainId,\n                    address(this)\n                )\n            );\n    }\n\n    // ============ ERC 20 ============\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view override returns (string memory) {\n        return token.name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view override returns (string memory) {\n        return token.symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view override returns (uint8) {\n        return token.decimals;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     */\n    function transfer(address _recipient, uint256 _amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     */\n    function approve(address _spender, uint256 _amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `recipient` cannot be the zero address.\n     * - `_sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``_sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public virtual override returns (bool) {\n        _transfer(_sender, _recipient, _amount);\n        _approve(\n            _sender,\n            _msgSender(),\n            allowances[_sender][_msgSender()].sub(\n                _amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            _spender,\n            allowances[_msgSender()][_spender].add(_addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least\n     * `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            _spender,\n            allowances[_msgSender()][_spender].sub(\n                _subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return supply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address _account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return balances[_account];\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address _owner, address _spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `_sender` to `_recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address.\n     * - `_sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address _sender,\n        address _recipient,\n        uint256 amount\n    ) internal virtual {\n        require(_sender != address(0), \"ERC20: transfer from the zero address\");\n        require(\n            _recipient != address(0),\n            \"ERC20: transfer to the zero address\"\n        );\n\n        _beforeTokenTransfer(_sender, _recipient, amount);\n\n        balances[_sender] = balances[_sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        balances[_recipient] = balances[_recipient].add(amount);\n        emit Transfer(_sender, _recipient, amount);\n    }\n\n    /** @dev Creates `_amount` tokens and assigns them to `_account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address _account, uint256 _amount) internal virtual {\n        require(_account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), _account, _amount);\n\n        supply = supply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Destroys `_amount` tokens from `_account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must have at least `_amount` tokens.\n     */\n    function _burn(address _account, uint256 _amount) internal virtual {\n        require(_account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(_account, address(0), _amount);\n\n        balances[_account] = balances[_account].sub(\n            _amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        supply = supply.sub(_amount);\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _amount\n    ) internal virtual {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Sets {decimals_} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals_} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        token.decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `_from` and `_to` are both non-zero, `_amount` of ``_from``'s tokens\n     * will be to transferred to `_to`.\n     * - when `_from` is zero, `_amount` tokens will be minted for `_to`.\n     * - when `_to` is zero, `_amount` of ``_from``'s tokens will be burned.\n     * - `_from` and `_to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/managers/BridgeTokenManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IBridgeTokenManager.sol\";\n\ncontract BridgeTokenManager is Ownable, IBridgeTokenManager {\n    uint8 public constant MAX_SIZE = 2;\n    bytes32 private immutable _salt;\n\n    mapping(bytes32 => Link) private _links;\n\n    constructor() {\n        _salt = keccak256(\n            abi.encodePacked(\n                blockhash(block.number - 1),\n                block.timestamp,\n                block.difficulty,\n                block.coinbase\n            )\n        );\n    }\n\n    /**\n     * @dev This should be responsible to get token mapping for cross chain\n     * @param addr address of token to get it's association\n     * @param chainId of domain where token used\n     */\n    function fetch(address addr, uint256 chainId)\n        public\n        view\n        override\n        returns (Token memory token, bool ok)\n    {\n        Link memory link = _get(addr, chainId);\n        if (!link.exist) {\n            return (token, ok);\n        }\n\n        uint256 currentChainId;\n        assembly {\n            currentChainId := chainid()\n        }\n\n        if (link.enterToken.chainId == currentChainId) {\n            token = link.enterToken;\n            ok = true;\n        } else if (link.exitToken.chainId == currentChainId) {\n            token = link.exitToken;\n            ok = true;\n        }\n        return (token, ok);\n    }\n\n    /**\n     * @dev This should be responsible to remove tokens connection between chains\n     * @param addr address of token to revoke\n     * @param chainId of domain where token used\n     */\n    function revoke(address addr, uint256 chainId) external override onlyOwner {\n        Link memory link = _get(addr, chainId);\n        require(link.exist, \"BridgeTokenManager: NOT_EXIST\");\n\n        _remove(link);\n\n        emit LinkRemoved(link);\n    }\n\n    /**\n     * @dev This should be responsible to connect tokens between chains\n     * @param tokens addresses on link connection\n     * @param issueTypes for tokens\n     * @param chainIds where they are located\n     */\n    function issue(\n        address[] calldata tokens,\n        IssueType[] calldata issueTypes,\n        uint256[] calldata chainIds\n    ) external override onlyOwner {\n        require(\n            tokens.length == issueTypes.length,\n            \"BridgeTokenManager: WRONG_LENGTH\"\n        );\n        require(\n            tokens.length == chainIds.length,\n            \"BridgeTokenManager: WRONG_LENGTH\"\n        );\n        require(tokens.length == MAX_SIZE, \"BridgeTokenManager: MAX_SIZE\");\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        require(chainIds[0] == chainId, \"BridgeTokenManager: WRONG_CHAIN_ID\");\n\n        Link memory link = _insert(\n            Token(tokens[0], issueTypes[0], chainIds[0]),\n            Token(tokens[1], issueTypes[1], chainIds[1])\n        );\n\n        emit LinkAdded(link);\n    }\n\n    function _set(Link memory link) private {\n        _links[_key(link.enterToken.addr, link.enterToken.chainId)] = link;\n        _links[_key(link.exitToken.addr, link.exitToken.chainId)] = link;\n    }\n\n    function _remove(Link memory link) private {\n        delete _links[_key(link.enterToken.addr, link.enterToken.chainId)];\n        delete _links[_key(link.exitToken.addr, link.exitToken.chainId)];\n    }\n\n    function _get(address addr, uint256 chainId)\n        private\n        view\n        returns (Link memory link)\n    {\n        link = _links[_key(addr, chainId)];\n    }\n\n    function _key(address addr, uint256 chainId)\n        private\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_salt, addr, chainId));\n    }\n\n    function _insert(Token memory enterToken, Token memory exitToken)\n        private\n        returns (Link memory)\n    {\n        Link memory enterLink = _get(enterToken.addr, enterToken.chainId);\n        require(!enterLink.exist, \"BridgeTokenManager: ENTER_EXIST\");\n\n        Link memory exitLink = _get(exitToken.addr, exitToken.chainId);\n        require(!exitLink.exist, \"BridgeTokenManager: EXIT_EXIST\");\n\n        Link memory link = Link(enterToken, exitToken, true);\n        _set(link);\n\n        return link;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/managers/BridgeCosignerManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"../interfaces/IBridgeCosignerManager.sol\";\n\ncontract BridgeCosignerManager is IBridgeCosignerManager {\n    using ECDSA for bytes32;\n\n    mapping(address => Cosigner) public cosigners;\n    uint8 public required;\n\n    constructor(\n        address[] memory cosigners_,\n        uint256[] memory chainIds_,\n        uint8 required_\n    ) {\n        require(\n            cosigners_.length == chainIds_.length,\n            \"BridgeCosignerManager: MISMATCH_VERIFIERS\"\n        );\n        require(required_ != 0, \"BridgeCosignerManager: MISSED_REQUIRED_COUNT\");\n        require(\n            required_ <= cosigners_.length,\n            \"BridgeCosignerManager: REQUIRED_MORE_THEN_COSIGNERS\"\n        );\n        required = required_;\n        for (uint8 i = 0; i < cosigners_.length; i++) {\n            address signer = cosigners_[i];\n            uint256 chainId = chainIds_[i];\n            require(\n                signer != address(0),\n                \"BridgeCosignerManager: ZERO_ADDRESS\"\n            );\n            cosigners[signer] = Cosigner(signer, true, chainId);\n        }\n    }\n\n    function recover(bytes32 hash, bytes calldata signature)\n        internal\n        pure\n        returns (address)\n    {\n        return hash.toEthSignedMessageHash().recover(signature);\n    }\n\n    // TODO: Add cosigner impl\n    // function addCosigner() external view;\n\n    function verify(\n        bytes32 commitment,\n        uint256 chainId,\n        bytes[] calldata signatures\n    ) external view override returns (bool) {\n        require(\n            required <= signatures.length,\n            \"BridgeCosignerManager: MISMATCH_SIGNATURES\"\n        );\n\n        address[] memory cached = new address[](signatures.length);\n        uint8 signersMatch;\n\n        for (uint8 i = 0; i < signatures.length; i++) {\n            address signer = recover(commitment, signatures[i]);\n            Cosigner memory cosigner = cosigners[signer];\n\n            if (\n                cosigner.active &&\n                cosigner.chainId == chainId &&\n                !inCache(cached, signer)\n            ) {\n                signersMatch++;\n                cached[i] = signer;\n                if (signersMatch == required) return true;\n            }\n        }\n\n        return false;\n    }\n\n    function inCache(address[] memory cached, address signer)\n        internal\n        pure\n        returns (bool hasCache)\n    {\n        for (uint8 j = 0; j < cached.length; j++) {\n            if (cached[j] == signer) {\n                hasCache = true;\n                break;\n            }\n            // prevent iteration if cache not updated in slot\n            if (cached[j] == address(0)) {\n                break;\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}